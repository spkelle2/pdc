/**
 * @file VwsUtility.hpp
 * @author Sean Kelley
 * @date 2023-02-13
 */

// standard library
#include <cmath> // floor, ceil
#include <cstdio> // cerr
#include <cstdlib> // source
#include <filesystem.hpp> // path
#include <fstream> // ofstream
#include <iostream> // endl
#include <string>
#include <vector>

// coin-or modules
#include "CbcModel.hpp" // CbcModel
#include "CglPreProcess.hpp" // CglPreProcess
#include "OsiClpSolverInterface.hpp" // OsiClpSolverInterface

// Eigen library
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <Eigen/SparseLU>

// vpc modules
#include "Disjunction.hpp" // Disjunction
#include "SolverHelper.hpp" // SolverHelper
#include "utility.hpp" // greaterThanVal, isVal, isZero

// project modules
#include "VwsUtility.hpp"

// namespaces
using namespace Eigen;
namespace fs = ghc::filesystem;

OsiClpSolverInterface extractSolverInterfaceFromGunzip(fs::path instancePath) {
  // check that the file meets expectations
  verify(fs::exists(instancePath),
       "The file path " + instancePath.string() + " does not exist.");

  // unzip the file if necessary
  std::string extension = instancePath.extension();
  if (extension == ".gz") {
    // unzip and read the file
    std::string unzipCommand = "gunzip -k -f " + instancePath.string();
    std::system(unzipCommand.c_str());
    instancePath.replace_extension("");
  }

  // check that we have a .mps file
  verify(instancePath.extension() == ".mps",
         "The file path " + instancePath.string() + " must be .mps or .mps.gz file");

  // read instancePath into a CbcModel
  OsiClpSolverInterface instanceSolver;
  instanceSolver.readMps(instancePath.c_str(), true, false);
  return instanceSolver;
}

// get the variable names from an OsiSolverInterface
std::vector<std::string> getVariableNames(const OsiSolverInterface& instanceSolver) {
  std::vector<std::string> variableNames;
  for (int i = 0; i < instanceSolver.getNumCols(); i++) {
    variableNames.push_back(instanceSolver.getColName(i, 0));
  }
  return variableNames;
}

// get the constraint names from an OsiSolverInterface
std::vector<std::string> getConstraintNames(const OsiSolverInterface& instanceSolver) {
  std::vector<std::string> constraintNames;
  for (int i = 0; i < instanceSolver.getNumRows(); i++) {
    constraintNames.push_back(instanceSolver.getRowName(i, 0));
  }
  return constraintNames;
}

/** writes solution in <variableValue> to <solutionPath>. Removes previous
 * solution recorded at <solutionPath>. */
void writeSolution(std::vector<double> variableValues, std::vector<std::string> variableNames,
                   fs::path solutionPath){

  // check that the inputs meet expectations
  verify(fs::exists(solutionPath.parent_path()),
         "The directory " + solutionPath.parent_path().string() + " does not exist.");
  verify(variableNames.size() == variableValues.size(),
         "The number of variable names must match the number of columns in the model. " +
         std::to_string(variableNames.size()) + " != " + std::to_string(variableValues.size()));

  // get rid of the old solution if there is one
  if (fs::exists(solutionPath)) {
    fs::remove(solutionPath);
  }

  // write the current solution
  std::ofstream file(solutionPath);
  for (int i = 0; i < variableValues.size(); i++) {
    file << variableNames[i] + " " + std::to_string(variableValues[i]) << std::endl;
  }
  file.close();
}

/** transform solutions from the presolved model to the original instance.
 * Augmented from CbcModel::putBackSolutions */
void putBackSolutions(CbcModel *presolvedModel, CbcModel *model, CglPreProcess *preProcess){
  int numberSolutions = presolvedModel->numberSavedSolutions();
  int numberColumns = presolvedModel->getNumCols();
  if (numberSolutions >= 1) {
    model->deleteSolutions();
    double *bestSolution =
        CoinCopyOfArray(presolvedModel->bestSolution(), numberColumns);
    double objectiveValue = presolvedModel->getObjValue();
    for (int iSolution = numberSolutions - 1; iSolution >= 0; iSolution--) {
      presolvedModel->setCutoff(COIN_DBL_MAX);
      presolvedModel->solver()->setColSolution(
          presolvedModel->savedSolution(iSolution));
      preProcess->postProcess(*presolvedModel->solver(), false);
      model->setBestSolution(preProcess->originalModel()->getColSolution(),
                             model->solver()->getNumCols(),
                             presolvedModel->savedSolutionObjective(iSolution));
    }
    presolvedModel->setBestObjectiveValue(objectiveValue);
    presolvedModel->solver()->setColSolution(bestSolution);
  }
}

/// the following functions are copied from Strengthening, by A. M. Kazachkov

/** Get the Farkas multipliers for the disjunctive cuts generated by the VPC generator.
 *  The multipliers are returned as a vector of vectors of vectors of doubles.
 *  The first index is the cut index, the second index is the disjunctive term index,
 *  and the third index is the index of the variable (both decision and slack) in the disjunctive term.
 *  Borrowed from Strengthening's main.cpp */
std::vector< std::vector < std::vector<double> > > getFarkasMultipliers(
    const OsiSolverInterface& solver, const Disjunction& disj, const OsiCuts& currCuts) {
  
  std::vector< std::vector< std::vector<double> > > v;
  v.resize(currCuts.sizeCuts());

  for (int cut_ind = 0; cut_ind < currCuts.sizeCuts(); cut_ind++) {
    v[cut_ind].resize(disj.num_terms);
  }
  for (int term_ind = 0; term_ind < disj.num_terms; term_ind++) {
    OsiSolverInterface* termSolver;
    disj.getSolverForTerm(termSolver, term_ind, &solver, false, .001, NULL, true);
    if (!termSolver) {
      printf("Disjunctive term %d/%d not created successfully.\n", term_ind+1, disj.num_terms);
      verify(false, ""); // i think this should be a break right?
    }
    for (int cut_ind = 0; cut_ind < currCuts.sizeCuts(); cut_ind++) {
      const OsiRowCut* disjCut = currCuts.rowCutPtr(cut_ind);

      // For each term of the disjunction, we need to explicitly add the constraint(s)
      // defining the disjunctive term. In the form a^T x >= b
      const CoinPackedVector lhs = disjCut->row();
      const double rhs = disjCut->lb();
      getCertificate(v[cut_ind][term_ind], lhs.getNumElements(), lhs.getIndices(),
                     lhs.getElements(), rhs, termSolver);
    } // loop over cuts
  } // loop over disjunctive terms

  return v;
}

/// Given problem is (with A an [m x n] matrix) we know this because of how we defined termSolver
///   Ax - s = b
///   x >= 0
///   s >= 0
/// Suppose the basis is B (m columns); note that some of these might be slack variables
/// Denote by N the remaining n columns (the cobasis)
///
/// If solver is proven optimal, and the cut is valid for the basis cone,
/// then it suffices to take the inverse of the optimal basis
/// In particular, we want alpha^T = v^T A
///
/// Note that alpha is n-dimensional, v is m-dimensional
/// The components of v corresponding to rows in which the slack is basic will be 0
/// We need to get access to the inverse of the nxn submatrix of A corresponding to nonbasic slacks
///
/// * Invertible case
/// If A is invertible,
/// then we can take v^T = alpha^T A^{-1}
/// or, equivalently, v = (A^{-1})^T alpha
/// This means that v_j can be calculated as the dot product of the j-th column of A^{-1} with alpha
///
/// * General case
/// If A is not invertible, then we need only consider the relaxed corner polyhedron
/// That is, we only need the basis inverse applied to the matrix
void getCertificate(
    /// [out] Farkas multipliers (vector of length m + m_t + n)
    std::vector<double>& v,
    /// [in] number of nonzero cut coefficients
    const int num_elem,
    /// [in] indices of nonzero cut coefficients
    const int* const ind,
    /// [in] nonzero cut coefficients
    const double* const coeff,
    /// [in] rhs of cut
    const double cut_rhs,
    // [in] LP solver corresponding to disjunctive term
    OsiSolverInterface* const solver) {

  v.clear();
  v.resize(solver->getNumCols() + solver->getNumRows(), 0.0);

  // Get dense cut coefficients so that we can set the objective vector to
  // determine which constraints are active (i.e. contribute to this cut)
  // if parameterizing the cut, we can skip this part, just know it might not be feasible
  std::vector<double> cut_coeff(solver->getNumCols(), 0.0);
  for (int i = 0; i < num_elem; i++) {
    cut_coeff[ind[i]] = coeff[i];
  }

  // find the basis that generates this cut
  solver->setObjective(cut_coeff.data());
  solver->enableFactorization();
  solver->resolve();
  CoinWarmStartBasis* basis = dynamic_cast<CoinWarmStartBasis*>(solver->getWarmStart());
  // infeasible term - no cut and certificate is 0
  if (!solver->isProvenOptimal()) {
    return;
  }

  // Collect nonbasic variables - i.e. the decision and slack variables tight against one of their bounds
  std::vector<int> rows, cols;
  for (int var = 0; var < solver->getNumCols() + solver->getNumRows(); var++) {
    if (!isBasicVar(solver, var)) {
      if (var < solver->getNumCols()) {
        // decision variable tight at bound => active root variable bound constraint
        cols.push_back(var);
      } else {
        // slack variable tight at bound means active root or disjunctive (i.e. tightened variable) constraint
        rows.push_back(var - solver->getNumCols());
      }
    }
  }
  verify(cols.size() + rows.size() == solver->getNumCols(),
         "nonbasis should have same number of elements as there are decision variables");

  Eigen::SparseMatrix<double,Eigen::RowMajor> A;
  createEigenMatrix(A, solver, rows, cols);
  assert(A.rows() == solver->getNumCols());

  // Now set up right-hand side for solver (this vector is the same as our alpha vector/cut coefs)
  Eigen::VectorXd b(solver->getNumCols());
  b.setZero();
  for (int tmp_ind = 0; tmp_ind < num_elem; tmp_ind++) {
    b(ind[tmp_ind]) = coeff[tmp_ind];
  }

  Eigen::VectorXd x(solver->getNumCols());
  solveLinearSystem(x, A.transpose(), b);

  int tmp_ind = 0;
  for (const int& row : rows) {
    const double mult = 1.; //(solver->getRowSense()[row] == 'L') ? -1. : 1.;
    v[row] = mult * x(tmp_ind);
    tmp_ind++;
  }
  for (const int& col : cols) {
    const double mult = 1.; //isNonBasicUBVar(solver, col) ? -1. : 1.;
    v[solver->getNumRows() + col] = mult * x(tmp_ind);
    tmp_ind++;
  }

  // Obtain the cut that the certificate yields (should be the same/really close as the original cut)
  std::vector<double> new_coeff(solver->getNumCols());
  double new_rhs = 0.0;
  getCutFromCertificate(new_coeff, new_rhs, v, solver);

  // if we nerfed the cut for numerical stability error, then we should nerf the certificate
  std::vector<double> zero_vector = std::vector<double>(new_coeff.size(), 0.0);
  if (new_coeff == zero_vector) {
    fprintf(stderr, "setting all farkas coefficients to 0\n");
    v = std::vector<double>(v.size(), 0.0);
    return;
  }

  // otherwise do aleks' check of making sure we get the same cut back
  int num_errors = 0;
  double total_diff = 0.;
  for (int i = 0; i < solver->getNumCols(); i++) {
    const double diff = cut_coeff[i] - new_coeff[i];
    if (greaterThanVal(std::abs(diff), 0.0)) {
      fprintf(stderr, "%d: cut: %g\tcalc: %g\tdiff: %g\n", i, cut_coeff[i], new_coeff[i], diff);
      num_errors++;
      total_diff += std::abs(diff);
    }
  }
  std::cout << "cut rhs: " << cut_rhs << "\tcalc: " << new_rhs << "\tdiff: " << new_rhs - cut_rhs << std::endl;
  if (num_errors > 0) {
    const bool should_continue = isZero(total_diff, 1e-3);
    if (should_continue) {
      // Send warning
      warning_msg(warnstring,
                  "Number of differences between true and calculated cuts: %d. Total difference: %g. Small enough difference that we will try to continue, but beware of numerical issues.\n",
                  num_errors, total_diff);
    } else {
      // Exit
      error_msg(errorstring,
                "Number of differences between true and calculated cuts: %d. Total difference: %g. Exiting.\n",
                num_errors, total_diff);
      writeErrorToLog(errorstring, NULL);
    }
    fprintf(stderr, "x:\n");
    for (int i = 0; i < solver->getNumCols(); i++) {
      fprintf(stderr, "x[%d] = %g\n", i, x(i));
    }
    fprintf(stderr, "b:\n");
    for (int i = 0; i < solver->getNumCols(); i++) {
      fprintf(stderr, "b[%d] = %g\n", i, b(i));
    }
    fprintf(stderr, "v:\n");
    for (int i = 0; i < (int) v.size(); i++) {
      fprintf(stderr, "v[%d] = %g\n", i, v[i]);
    }
    if (!should_continue) {
      verify(false, "getCertificate: failed to get the same cut back.");
    }
  }
  solver->disableFactorization();
} /* getCertificate */

/** create the basis matrix for generating the cut certificate */
void createEigenMatrix(
    /// [out] sparse matrix, in row-major form
    Eigen::SparseMatrix<double,Eigen::RowMajor>& M,
    /// [in] COIN-OR solver
    const OsiSolverInterface* const solver,
    /// [in] set of rows that we want to consider
    const std::vector<int>& rows,
    /// [in] set of variable bounds we want to explicitly use
    const std::vector<int>& cols) {
  // Get sparse matrix from COIN-OR, in row-major form
  const CoinPackedMatrix* const mat = solver->getMatrixByRow();

  verify(!mat->isColOrdered(), "Matrix should be in row-major form");

  const bool doAll = (rows.size() + cols.size()) == 0;
  const int num_cols = mat->getNumCols();
  const int num_selected_rows = doAll ? mat->getNumRows() + mat->getNumCols() : rows.size() + cols.size();
  int num_elem_removed = 0, num_rows_removed = 0;

  // Prepare sparse matrix
  M.resize(num_selected_rows, num_cols);
  M.reserve(mat->getNumElements() + cols.size());

  const bool batchInsert = true;
  std::vector<Eigen::Triplet<double> > tripletList;
  if (batchInsert) {
    tripletList.reserve(mat->getNumElements() + cols.size());
  }
  unsigned tmp_ind = 0;
  for (int row = 0; row < mat->getNumRows(); row++) {
    if (doAll || (tmp_ind < rows.size() && rows[tmp_ind] == row)) {
      if (batchInsert) prepareRow(tripletList, mat, row, tmp_ind);
      else insertRow(M, mat, row, tmp_ind);
      tmp_ind++;
    } else {
      num_elem_removed += mat->getVectorSize(row);
      num_rows_removed++;
    }
  }
  // Add explicit column lower bound rows
  // We *do not* ``complement'' the upper bounded variables because we would then have to
  // also complement ``alpha'' when we use it for the right-hand side;
  // these two negations cancel each other out
  for (const int& col : cols) {
    const double val = 1.0;
    if (batchInsert) tripletList.push_back(Eigen::Triplet<double>(tmp_ind, col, val));
    else M.insert(tmp_ind, col) = val;
    tmp_ind++;
  }
  if (doAll) {
    for (int col = 0; col < solver->getNumCols(); col++) {
      const double val = 1.0;
      if (batchInsert) tripletList.push_back(Eigen::Triplet<double>(tmp_ind, col, val));
      else M.insert(tmp_ind, col) = val;
      tmp_ind++;
    }
  }
  if (batchInsert) {
    M.setFromTriplets(tripletList.begin(), tripletList.end());
  }

  M.makeCompressed();

#ifdef TRACE
  // Check matrix
  assert(M.rows() == num_selected_rows);
  assert(M.cols() == num_cols);
  assert(M.nonZeros() == (long int) (mat->getNumElements() - num_elem_removed + (doAll ? num_cols : cols.size())));
#endif
} /* createEigenMatrix (sparse) */

/** Find the solution x to Ax = b */
void solveLinearSystem(
    /// [out] solution to the linear system (if one was successfully found)
    VectorXd& x,
    /// [in] A matrix
    const SparseMatrix<double>& A,
    /// [in] right-hand side to the linear system
    const VectorXd& b) {
  SparseLU<SparseMatrix<double> > solver;
  solver.compute(A);
  if (solver.info()!=Success) {
    // decomposition failed
    verify(false, "solveLinearSystem: failed to create decomposition.");
  }
  x = solver.solve(b);
  if (solver.info()!=Success) {
    // solving failed
    verify(false, "solveLinearSystem: failed to solve linear system.");
  }

#ifdef TRACE
  VectorXd tmp = A * x;
  for (int i = 0; i < b.size(); i++) {
    if (!isVal(tmp(i), b(i))) {
      fprintf(stderr, "Calculated A_i . x = %f instead of correct value of b_i = %f.\n", tmp(i), b(i));
    }
  }
#endif
} /* solveLinearSystem */

void prepareRow(
    /// [out] Eigen::Triplet<double> that we are updating
    std::vector<Eigen::Triplet<double> >& tripletList,
    /// [in] sparse matrix from COIN-OR, in row-major form
    const CoinPackedMatrix* const mat,
    /// [in] row we are inserting
    const int row,
    /// [in] row in which to insert this value
    const int tmp_row) {
  const int* cols = mat->getIndices();
  const double* elem = mat->getElements();

  const int start = mat->getVectorFirst(row);
  const int end = mat->getVectorLast(row);
  for (int ind = start; ind < end; ind++) {
    const double j = cols[ind];
    const double el = elem[ind];
    tripletList.push_back(Eigen::Triplet<double>(tmp_row,j,el));
  }
} /* prepareRow */

void insertRow(
    /// [out] sparse matrix, in row-major form
    Eigen::SparseMatrix<double,Eigen::RowMajor>& M,
    /// [in] sparse matrix from COIN-OR, in row-major form
    const CoinPackedMatrix* const mat,
    /// [in] row we are inserting
    const int row,
    /// [in] row in which to insert this entry
    const int tmp_row) {
  const int* cols = mat->getIndices();
  const double* elem = mat->getElements();

  const int start = mat->getVectorFirst(row);
  const int end = mat->getVectorLast(row);
  for (int ind = start; ind < end; ind++) {
    const double j = cols[ind];
    const double el = elem[ind];
    M.insert(tmp_row,j) = el;
  }
} /* insertRow */

/** Find alpha and beta such that alpha^T x >= beta for all x feasible for solver
 *  where alpha and beta are derived by taking a linear combination of solver's
 *  constraints with coefficients prescribed by the Farkas multipliers v.
 *  Note: First m+m_t rows of v correspond to A;D^t; the next n are bounds on the variables */
void getCutFromCertificate(
    /// [out] calculated cut coefficients
    std::vector<double>& alpha,
    /// [out] calculated cut bound
    double& beta,
    /// [in] Farkas multipliers
    const std::vector<double>& v,
    /// [in] LP solver corresponding to disjunctive term
    const OsiSolverInterface* const solver) {

  verify(!solver->isProvenPrimalInfeasible(),
         "cannot calculate cut with infeasible termSolver.\n");
  verify(v.size() == solver->getNumRows() + solver->getNumCols(), "The number of "
         "Farkas multipliers should match the number of constraints and variables.\n");

  alpha.clear();
  alpha.resize(solver->getNumCols(), 0.0);
  beta = 0.0;

  //      [ A
  // A^t = D^t  : I diagonal n X n matrix with +/- 1's on the diagonal
  //        I ]
  //
  //      [  b
  // b^t = D^t_0  : x_0 includes all active bounds on x
  //        x_0 ]
  //
  // alpha^T = {v^t}^T A^t = [v^t dot A^t_{*,1}, ..., v^t dot A^t_{*,n}]
  //
  //           [        [ A_{*,1}                 [ A_{*,n}
  //         =  v^t dot  D^t_{*,1} , ..., v^t dot  D^t_{*,n}
  //                      I_{*,1} ]                 I_{*,n} ]]
  //
  //           [        [ A_{*,1}                 [ A_{*,n}
  //         =  v^t dot  D^t_{*,1} , ..., v^t dot  D^t_{*,n}
  //                      I_{1,1} ]                 I_{n,n} ]]
  //
  // beta = v^t b^t = v^t_{1:m} dot b + v^t_{m+1:m+m^t} dot D^t_0 + v^t_{m+mt^t+1:m+m^t+n} dot x_0
  const CoinPackedMatrix* mat = solver->getMatrixByCol();
  double val;
  for (int col = 0; col < solver->getNumCols(); col++) {
    const int start = mat->getVectorFirst(col);
    const int colFarkasIndex = solver->getNumRows() + col;
    // v^t_{1:m} dot A^t_{*,col} + v^t_{m+1:m+mt^t} D^t_{*,col}
    alpha[col] += dotProduct(mat->getVectorSize(col),
                             mat->getIndices() + start, mat->getElements() + start, v.data());
    // v^t_{m+mt^t+1:m+mt^t+n} I^t_{*,col} = v^t_{m+mt^t+col} I^t_{col,col}
    alpha[col] += v[colFarkasIndex];
    // we standardized to Ax >= b, so v^t_{m+m^t+col} > 0 => x_0 is a lower bound
    // and v^t_{m+m^t+col} < 0 => x_0 is an upper bound
    // v^t_{m+m^t+col} dot x_0_{col}
    if (greaterThanVal(v[colFarkasIndex], 0)){
      val = v[colFarkasIndex] * solver->getColLower()[col];
    } else if (lessThanVal(v[colFarkasIndex], 0)) {
      val = v[colFarkasIndex] * solver->getColUpper()[col];
    } else {
      val = 0.0;
    }
    // nerf the valid inequality for this term if we get a numerical error
    // the issue here is coming from eigen saying something that should be 0 is
    // small and on the wrong side of it, which leads our method here to use the wrong bound
    if (val > 1e30 || val < -1e30){
      fprintf(stderr, "messed up a farkas cofficient\n");
      alpha = std::vector<double>(alpha.size(), 0.0);
      beta = 0.0;
      return;
    }
    beta += val;
  }

  // v^t_{1:m} dot b + v^t_{m+1:m+m^t} dot D^t_0
  for (int row = 0; row < solver->getNumRows(); row++) {
    // Again, we standardized to Ax >= b, so v^t_{row} > 0 => it's lower bounded
    // while and v^t_{row} < 0 => it's upper bounded
    if (greaterThanVal(v[row], 0)){
      val = v[row] * solver->getRowLower()[row];
    } else if (lessThanVal(v[row], 0)) {
      val = v[row] * solver->getRowUpper()[row];
    } else {
      val = 0.0;
    }
    if (val > 1e30 || val < -1e30){
      fprintf(stderr, "messed up a farkas cofficient\n");
      alpha = std::vector<double>(alpha.size(), 0.0);
      beta = 0.0;
      return;
    }
    beta += val;
  }
} /* getCutFromCertificate */

/** find the smallest value in each column given a vector of row vectors */
std::vector<double> elementWiseMax(std::vector< std::vector<double> > a){
  std::vector<double> maxes(a[0].size(), -1e50);
  for (int termIdx = 0; termIdx < a.size(); termIdx++){
    for (int colIdx = 0; colIdx < a[termIdx].size(); colIdx++){
      if (a[termIdx][colIdx] > maxes[colIdx]){
        maxes[colIdx] = a[termIdx][colIdx];
      }
    }
  }
  return maxes;
}

/** find the smallest value in a vector */
double min(std::vector<double> a){
  double min = 1e50;
  for (int i = 0; i < a.size(); i++){
    if (a[i] < min){
      min = a[i];
    }
  }
  return min;
}

/** find the largest value in a vector */
double max(std::vector<double> a){
  double max = -1e50;
  for (int i = 0; i < a.size(); i++){
    if (a[i] > max){
      max = a[i];
    }
  }
  return max;
}

/** check if cut is valid for given solution */
bool isFeasible(
    /// [in] problem
    const OsiRowCut& cut,
    /// [in] solution
    const std::vector<double>& sol) {

  double sum = 0.0;
  for (int ind = 0; ind < cut.row().getNumElements(); ind++) {
    const double j = cut.row().getIndices()[ind];
    const double el = cut.row().getElements()[ind];
    sum += el * sol[j];
  }
  if (lessThanVal(sum, cut.lb()) || greaterThanVal(sum, cut.ub())) {
    // print the sum, the cut lower bound, and cut upper bound
    std::cout << " lb: " << cut.lb() << "sum: " << sum << " ub: " << cut.ub() << std::endl;
    return false;
  } else {
    return true;
  }
} /* isFeasible */

/** find the nonzero indices and elements of a vector */
void findNonZero(
    /// [in] vector
    const std::vector<double>& vec,
    /// [out] indices of nonzero elements
    std::vector<int>& indices,
    /// [out] nonzero elements
    std::vector<double>& elements) {

  indices.clear();
  elements.clear();
  for (int i = 0; i < vec.size(); i++){
    if (!isZero(vec[i])){
      indices.push_back(i);
      elements.push_back(vec[i]);
    }
  }
}

/** find the primal bound of a solver for a given solution pool */
double findPrimalBound(
    /// [in] solver
    OsiClpSolverInterface * si,
    /// [in] solution pool
    const std::set<std::vector<double>> solution_pool){

  // need to be minimizing
  ensureMinimizationObjective(si);

  double primal_bound = std::numeric_limits<double>::max();
  for (const auto & sol : solution_pool){
    double objective_value = 0.0;
    // calculate objective value for this solution
    for (int j = 0; j < si->getNumCols(); j++){
      objective_value += si->getObjCoefficients()[j] * sol[j];
    }
    if (isFeasible(*si, sol) && objective_value < primal_bound){
      primal_bound = objective_value;
    }
  }
  return primal_bound;
}

/** check if two solvers have the same coefficient matrix */
bool sameCoefficientMatrix(const OsiClpSolverInterface* solver1, const OsiClpSolverInterface* solver2) {
  // Check for null pointers
  if (!solver1 || !solver2) {
    std::cerr << "Error: One or both solver pointers are null." << std::endl;
    return false;
  }

  // Get the row-wise constraint matrices
  const CoinPackedMatrix* matrix1 = solver1->getMatrixByRow();
  const CoinPackedMatrix* matrix2 = solver2->getMatrixByRow();

  // Check if both matrices exist
  if (!matrix1 || !matrix2) {
    std::cerr << "Error: One or both solvers have no constraint matrix." << std::endl;
    return false;
  }

  // Compare dimensions
  if (matrix1->getNumRows() != matrix2->getNumRows() ||
      matrix1->getNumCols() != matrix2->getNumCols()) {
    return false;
  }

  // Compare individual nonzero entries
  const int* rowStart1 = matrix1->getVectorStarts();
  const int* rowStart2 = matrix2->getVectorStarts();
  const int* rowLength1 = matrix1->getVectorLengths();
  const int* rowLength2 = matrix2->getVectorLengths();
  const int* indices1 = matrix1->getIndices();
  const int* indices2 = matrix2->getIndices();
  const double* elements1 = matrix1->getElements();
  const double* elements2 = matrix2->getElements();

  for (int row = 0; row < matrix1->getNumRows(); ++row) {
    if (rowLength1[row] != rowLength2[row]) {
      return false; // Different number of nonzeros in a row
    }

    for (int i = rowStart1[row], j = rowStart2[row]; i < rowStart1[row] + rowLength1[row]; ++i, ++j) {
      if (indices1[i] != indices2[j] || !isVal(elements1[i], elements2[j])) {
        return false; // Different column index or coefficient value
      }
    }
  }

  return true; // Matrices are identical
}

/** check if a basis is feasible for a given solver */
bool isFeasible(const OsiSolverInterface* solver, const CoinWarmStartBasis* basis) {

  // verify we get solver and basis
  verify(solver, "should have solver");
  verify(basis, "should have basis");

  // verify that the basis fits the solver
  verify(solver->getNumCols() == basis->getNumStructural(),
         "Solver and basis do not have the same number of columns.");
  verify(solver->getNumRows() == basis->getNumArtificial(),
         "Solver and basis do not have the same number of rows.");

  // set the warm start
  OsiClpSolverInterface* tmp_solver = dynamic_cast<OsiClpSolverInterface*>(solver->clone());
  tmp_solver->setWarmStart(basis);

  // refactorize the basis and reevaluate the solution
  ClpSimplex* clp = tmp_solver->getModelPtr();
  clp->setMaximumIterations(0);
  tmp_solver->resolve();

  // save the solution
  std::vector<double> x(solver->getColSolution(), solver->getColSolution() + solver->getNumCols());

  // check if it is feasible
  return isFeasible(*solver, x, true);

//  std::vector<int> rows, cols, row_bounds, col_bounds;
//  for (int var = 0; var < solver->getNumCols() + solver->getNumRows(); var++) {
//    if (var < solver->getNumCols()){
//      if (basis->getStructStatus(var) != CoinWarmStartBasis::basic){
//        // decision variable tight at bound => active root variable bound constraint
//        cols.push_back(var);
//        if (basis->getStructStatus(var) == CoinWarmStartBasis::atLowerBound) {
//          col_bounds.push_back(solver->getColLower()[var]);
//        } else if (basis->getStructStatus(var) == CoinWarmStartBasis::atUpperBound) {
//          col_bounds.push_back(solver->getColUpper()[var]);
//        }
//      }
//    } else {
//      if (basis->getArtifStatus(var - solver->getNumCols()) != CoinWarmStartBasis::basic){
//        // slack variable tight at bound means active root or disjunctive (i.e. tightened variable) constraint
//        rows.push_back(var - solver->getNumCols());
//
//        if (basis->getArtifStatus(var - solver->getNumCols()) == CoinWarmStartBasis::atLowerBound) {
//          row_bounds.push_back(solver->getRowLower()[var - solver->getNumCols()]);
//        } else if (basis->getArtifStatus(var - solver->getNumCols()) == CoinWarmStartBasis::atUpperBound) {
//          row_bounds.push_back(solver->getRowUpper()[var - solver->getNumCols()]);
//        }
//      }
//    }
//  }
//  verify(cols.size() + rows.size() == solver->getNumCols(),
//         "nonbasis should have same number of elements as there are decision variables");
//
//  // if we had a nonbasic variable not at a bound, I'm not sure how to check for
//  // feasibility, so just give up :/
//  if (rows.size() != row_bounds.size() || cols.size() != col_bounds.size()) {
//    return -1;
//  }
//
//  // Get active constraints as a matrix - constraints then variable bounds
//  Eigen::SparseMatrix<double,Eigen::RowMajor> A;
//  createEigenMatrix(A, solver, rows, cols);
//  assert(A.rows() == solver->getNumCols());
//
//  // collect the bounds - constraints then variables
//  Eigen::VectorXd b(solver->getNumCols());
//  b.setZero();
//  for (int tmp_ind = 0; tmp_ind < A.rows(); tmp_ind++) {
//    if (tmp_ind < rows.size()) {
//      b(tmp_ind) = row_bounds[tmp_ind];
//    } else {
//      b(tmp_ind) = col_bounds[tmp_ind - rows.size()];
//    }
//  }
//
//  // find x satisfying Ax = b
//  Eigen::VectorXd x(solver->getNumCols());
//  solveLinearSystem(x, A, b);
}
