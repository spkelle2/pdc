/**
 * @file VwsUtility.hpp
 * @author Sean Kelley
 * @date 2023-02-13
 */

// standard library
#include <cmath> // floor, ceil
#include <cstdio> // cerr
#include <cstdlib> // source
#include <ghc/filesystem.hpp> // path
#include <fstream> // ofstream
#include <iostream> // endl
#include <string>
#include <vector>

// coin-or modules
#include "CbcModel.hpp" // CbcModel
#include "CglPreProcess.hpp" // CglPreProcess
#include "OsiClpSolverInterface.hpp" // OsiClpSolverInterface

// Eigen library
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <Eigen/SparseLU>

// vpc modules
#include "Disjunction.hpp" // Disjunction
#include "SolverHelper.hpp" // SolverHelper
#include "utility.hpp" // greaterThanVal, isVal, isZero

// project modules
#include "VwsUtility.hpp"

// namespaces
using namespace Eigen;
namespace fs = ghc::filesystem;

void verify(bool condition, const std::string& msg) {
  if (!condition) {
    std::cerr << msg << std::endl;
    assert(false);  // cause failure with a stack trace
  }
}

OsiClpSolverInterface extractSolverInterfaceFromGunzip(fs::path instancePath) {
  // check that the file meets expectations
  verify(fs::exists(instancePath),
       "The file path " + instancePath.string() + " does not exist.");

  // unzip the file if necessary
  std::string extension = instancePath.extension();
  if (extension == ".gz") {
    // unzip and read the file
    std::string unzipCommand = "gunzip -k -f " + instancePath.string();
    std::system(unzipCommand.c_str());
    instancePath.replace_extension("");
  }

  // check that we have a .mps file
  verify(instancePath.extension() == ".mps",
         "The file path " + instancePath.string() + " must be .mps or .mps.gz file");

  // read instancePath into a CbcModel
  OsiClpSolverInterface instanceSolver;
  instanceSolver.readMps(instancePath.c_str(), true, false);
  return instanceSolver;
}

// get the variable names from an OsiSolverInterface
std::vector<std::string> getVariableNames(const OsiSolverInterface& instanceSolver) {
  std::vector<std::string> variableNames;
  for (int i = 0; i < instanceSolver.getNumCols(); i++) {
    variableNames.push_back(instanceSolver.getColName(i, 0));
  }
  return variableNames;
}

// get the constraint names from an OsiSolverInterface
std::vector<std::string> getConstraintNames(const OsiSolverInterface& instanceSolver) {
  std::vector<std::string> constraintNames;
  for (int i = 0; i < instanceSolver.getNumRows(); i++) {
    constraintNames.push_back(instanceSolver.getRowName(i, 0));
  }
  return constraintNames;
}

/** writes solution in <variableValue> to <solutionPath>. Removes previous
 * solution recorded at <solutionPath>. */
void writeSolution(std::vector<double> variableValues, std::vector<std::string> variableNames,
                   fs::path solutionPath){

  // check that the inputs meet expectations
  verify(fs::exists(solutionPath.parent_path()),
         "The directory " + solutionPath.parent_path().string() + " does not exist.");
  verify(variableNames.size() == variableValues.size(),
         "The number of variable names must match the number of columns in the model. " +
         std::to_string(variableNames.size()) + " != " + std::to_string(variableValues.size()));

  // get rid of the old solution if there is one
  if (fs::exists(solutionPath)) {
    fs::remove(solutionPath);
  }

  // write the current solution
  std::ofstream file(solutionPath);
  for (int i = 0; i < variableValues.size(); i++) {
    file << variableNames[i] + " " + std::to_string(variableValues[i]) << std::endl;
  }
  file.close();
}

/** transform solutions from the presolved model to the original instance.
 * Augmented from CbcModel::putBackSolutions */
void putBackSolutions(CbcModel *presolvedModel, CbcModel *model, CglPreProcess *preProcess){
  int numberSolutions = presolvedModel->numberSavedSolutions();
  int numberColumns = presolvedModel->getNumCols();
  if (numberSolutions >= 1) {
    model->deleteSolutions();
    double *bestSolution =
        CoinCopyOfArray(presolvedModel->bestSolution(), numberColumns);
    double objectiveValue = presolvedModel->getObjValue();
    for (int iSolution = numberSolutions - 1; iSolution >= 0; iSolution--) {
      presolvedModel->setCutoff(COIN_DBL_MAX);
      presolvedModel->solver()->setColSolution(
          presolvedModel->savedSolution(iSolution));
      preProcess->postProcess(*presolvedModel->solver(), false);
      model->setBestSolution(preProcess->originalModel()->getColSolution(),
                             model->solver()->getNumCols(),
                             presolvedModel->savedSolutionObjective(iSolution));
    }
    presolvedModel->setBestObjectiveValue(objectiveValue);
    presolvedModel->solver()->setColSolution(bestSolution);
  }
}

/// the following functions are copied from Strengthening, by A. M. Kazachkov

/** Get the Farkas multipliers for the disjunctive cuts generated by the VPC generator.
 *  The multipliers are returned as a vector of vectors of vectors of doubles.
 *  The first index is the cut index, the second index is the disjunctive term index,
 *  and the third index is the index of the variable in the disjunctive term.
 *  Borrowed from Strengthening's main.cpp */
std::vector< std::vector < std::vector<double> > > getFarkasMultipliers(
    const OsiSolverInterface& solver, const Disjunction& disj, const OsiCuts& currCuts) {
  
  std::vector< std::vector< std::vector<double> > > v;
  v.resize(currCuts.sizeCuts());

  for (int cut_ind = 0; cut_ind < currCuts.sizeCuts(); cut_ind++) {
    v[cut_ind].resize(disj.num_terms);
  }
  for (int term_ind = 0; term_ind < disj.num_terms; term_ind++) {
    OsiSolverInterface* termSolver;
    disj.getSolverForTerm(termSolver, term_ind, &solver, false, .001, NULL, false, false);
    if (!termSolver) {
      printf("Disjunctive term %d/%d not created successfully.\n", term_ind+1, disj.num_terms);
      exit(1); // i think this should be a break right?
    }
    for (int cut_ind = 0; cut_ind < currCuts.sizeCuts(); cut_ind++) {
      const OsiRowCut* disjCut = currCuts.rowCutPtr(cut_ind);

      // For each term of the disjunction, we need to explicitly add the constraint(s)
      // defining the disjunctive term. In the form a^T x >= b
      const CoinPackedVector lhs = disjCut->row();
      const double rhs = disjCut->lb();
      getCertificate(v[cut_ind][term_ind], lhs.getNumElements(), lhs.getIndices(),
                     lhs.getElements(), rhs, termSolver);
    } // loop over cuts
  } // loop over disjunctive terms

  return v;
}

/// Given problem is (with A an [m x n] matrix)
///   Ax - s = b
///   x >= 0
///   s >= 0
/// Suppose the basis is B (m columns); note that some of these might be slack variables
/// Denote by N the remaining n columns (the cobasis)
///
/// If solver is proven optimal, and the cut is valid for the basis cone,
/// then it suffices to take the inverse of the optimal basis
/// In particular, we want alpha^T = v^T A
///
/// Note that alpha is n-dimensional, v is m-dimensional
/// The components of v corresponding to rows in which the slack is basic will be 0
/// We need to get access to the inverse of the nxn submatrix of A corresponding to nonbasic slacks
///
/// * Invertible case
/// If A is invertible,
/// then we can take v^T = alpha^T A^{-1}
/// or, equivalently, v = (A^{-1})^T alpha
/// This means that v_j can be calcuated as the dot product of the j-th column of A^{-1} with alpha
///
/// * General case
/// If A is not invertible, then we need only consider the relaxed corner polyhedron
/// That is, we only need the basis inverse applied to the matrix
void getCertificate(
    /// [out] Farkas multipliers (vector of length m + m_t + n)
    std::vector<double>& v,
    /// [in] number of nonzero cut coefficients
    const int num_elem,
    /// [in] indices of nonzero cut coefficients
    const int* const ind,
    /// [in] nonzero cut coefficients
    const double* const coeff,
    /// [in] rhs of cut
    const double cut_rhs,
    // [in] LP solver corresponding to disjunctive term
    OsiSolverInterface* const solver) {

  v.clear();
  v.resize(solver->getNumCols() + solver->getNumRows(), 0.0);

  // Get dense cut coefficients so that we can set the objective vector to
  // determine which constraints are active (i.e. contribute to this cut)
  std::vector<double> cut_coeff(solver->getNumCols(), 0.0);
  for (int i = 0; i < num_elem; i++) {
    cut_coeff[ind[i]] = coeff[i];
  }
  solver->setObjective(cut_coeff.data());
  solver->resolve();
  if (!solver->isProvenOptimal()) {
    return;
  }
  solver->enableFactorization();

  // Collect nonbasic variables
  std::vector<int> rows, cols;
  for (int var = 0; var < solver->getNumCols() + solver->getNumRows(); var++) {
    if (!isBasicVar(solver, var)) {
      if (var < solver->getNumCols()) {
        cols.push_back(var);
      } else {
        rows.push_back(var - solver->getNumCols());
      }
    }
  }

  Eigen::SparseMatrix<double,Eigen::RowMajor> A;
  createEigenMatrix(A, solver, rows, cols);
  assert(A.rows() == solver->getNumCols());

  // Now set up right-hand side for solver (should be equal to alpha)
  Eigen::VectorXd b(solver->getNumCols());
  b.setZero();
  for (int tmp_ind = 0; tmp_ind < num_elem; tmp_ind++) {
    b(ind[tmp_ind]) = coeff[tmp_ind];
  }

  Eigen::VectorXd x(solver->getNumCols());
  solveLinearSystem(x, A.transpose(), b);

  int tmp_ind = 0;
  for (const int& row : rows) {
    const double mult = 1.; //(solver->getRowSense()[row] == 'L') ? -1. : 1.;
    v[row] = mult * x(tmp_ind);
    tmp_ind++;
  }
  for (const int& col : cols) {
    const double mult = 1.; //isNonBasicUBVar(solver, col) ? -1. : 1.;
    v[solver->getNumRows() + col] = mult * x(tmp_ind);
    tmp_ind++;
  }

  // Obtain the cut that the certificate yields (should be the same as the original cut)
  std::vector<double> new_coeff(solver->getNumCols());
  double new_rhs = 0.0;
  getCutFromCertificate(new_coeff, new_rhs, v, solver);

  int num_errors = 0;
  double total_diff = 0.;
  for (int i = 0; i < solver->getNumCols(); i++) {
    const double diff = cut_coeff[i] - new_coeff[i];
    if (greaterThanVal(std::abs(diff), 0.0)) {
      fprintf(stderr, "%d: cut: %g\tcalc: %g\tdiff: %g\n", i, cut_coeff[i], new_coeff[i], diff);
      num_errors++;
      total_diff += std::abs(diff);
    }
  }
  std::cout << "cut rhs: " << cut_rhs << "\tcalc: " << new_rhs << "\tdiff: " << new_rhs - cut_rhs << std::endl;
  if (num_errors > 0) {
    const bool should_continue = isZero(total_diff, 1e-3);
    if (should_continue) {
      // Send warning
      warning_msg(warnstring,
                  "Number of differences between true and calculated cuts: %d. Total difference: %g. Small enough difference that we will try to continue, but beware of numerical issues.\n",
                  num_errors, total_diff);
    } else {
      // Exit
      error_msg(errorstring,
                "Number of differences between true and calculated cuts: %d. Total difference: %g. Exiting.\n",
                num_errors, total_diff);
      writeErrorToLog(errorstring, NULL);
    }
    fprintf(stderr, "x:\n");
    for (int i = 0; i < solver->getNumCols(); i++) {
      fprintf(stderr, "x[%d] = %g\n", i, x(i));
    }
    fprintf(stderr, "b:\n");
    for (int i = 0; i < solver->getNumCols(); i++) {
      fprintf(stderr, "b[%d] = %g\n", i, b(i));
    }
    fprintf(stderr, "v:\n");
    for (int i = 0; i < (int) v.size(); i++) {
      fprintf(stderr, "v[%d] = %g\n", i, v[i]);
    }
    if (!should_continue) {
      exit(1);
    }
  }
  solver->disableFactorization();
} /* getCertificate */

/** create the basis matrix for generating the cut certificate */
void createEigenMatrix(
    /// [out] sparse matrix, in row-major form
    Eigen::SparseMatrix<double,Eigen::RowMajor>& M,
    /// [in] COIN-OR solver
    const OsiSolverInterface* const solver,
    /// [in] set of rows that we want to consider
    const std::vector<int>& rows,
    /// [in] set of variable bounds we want to explicitly use
    const std::vector<int>& cols) {
  // Get sparse matrix from COIN-OR, in row-major form
  const CoinPackedMatrix* const mat = solver->getMatrixByRow();

  verify(!mat->isColOrdered(), "Matrix should be in row-major form");

  const bool doAll = (rows.size() + cols.size()) == 0;
  const int num_cols = mat->getNumCols();
  const int num_selected_rows = doAll ? mat->getNumRows() + mat->getNumCols() : rows.size() + cols.size();
  int num_elem_removed = 0, num_rows_removed = 0;

  // Prepare sparse matrix
  M.resize(num_selected_rows, num_cols);
  M.reserve(mat->getNumElements() + cols.size());

  const bool batchInsert = true;
  std::vector<Eigen::Triplet<double> > tripletList;
  if (batchInsert) {
    tripletList.reserve(mat->getNumElements() + cols.size());
  }
  unsigned tmp_ind = 0;
  for (int row = 0; row < mat->getNumRows(); row++) {
    if (doAll || (tmp_ind < rows.size() && rows[tmp_ind] == row)) {
      if (batchInsert) prepareRow(tripletList, mat, row, tmp_ind);
      else insertRow(M, mat, row, tmp_ind);
      tmp_ind++;
    } else {
      num_elem_removed += mat->getVectorSize(row);
      num_rows_removed++;
    }
  }
  // Add explicit column lower bound rows
  // We *do not* ``complement'' the upper bounded variables because we would then have to
  // also complement ``alpha'' when we use it for the right-hand side;
  // these two negations cancel each other out
  for (const int& col : cols) {
    const double val = 1.0;
    if (batchInsert) tripletList.push_back(Eigen::Triplet<double>(tmp_ind, col, val));
    else M.insert(tmp_ind, col) = val;
    tmp_ind++;
  }
  if (doAll) {
    for (int col = 0; col < solver->getNumCols(); col++) {
      const double val = 1.0;
      if (batchInsert) tripletList.push_back(Eigen::Triplet<double>(tmp_ind, col, val));
      else M.insert(tmp_ind, col) = val;
      tmp_ind++;
    }
  }
  if (batchInsert) {
    M.setFromTriplets(tripletList.begin(), tripletList.end());
  }

  M.makeCompressed();

#ifdef TRACE
  // Check matrix
  assert(M.rows() == num_selected_rows);
  assert(M.cols() == num_cols);
  assert(M.nonZeros() == (long int) (mat->getNumElements() - num_elem_removed + (doAll ? num_cols : cols.size())));
#endif
} /* createEigenMatrix (sparse) */

/** Find the solution x to Ax = b */
void solveLinearSystem(
    /// [out] solution to the linear system (if one was successfully found)
    VectorXd& x,
    /// [in] A matrix
    const SparseMatrix<double>& A,
    /// [in] right-hand side to the linear system
    const VectorXd& b) {
  SparseLU<SparseMatrix<double> > solver;
  solver.compute(A);
  if (solver.info()!=Success) {
    // decomposition failed
    error_msg(errorstring, "solveLinearSystem: failed to create decomposition.\n");
    exit(1);
  }
  x = solver.solve(b);
  if (solver.info()!=Success) {
    // solving failed
    error_msg(errorstring, "solveLinearSystem: solving failed.\n");
    exit(1);
  }

#ifdef TRACE
  VectorXd tmp = A * x;
  for (int i = 0; i < b.size(); i++) {
    if (!isVal(tmp(i), b(i))) {
      fprintf(stderr, "Calculated A_i . x = %f instead of correct value of b_i = %f.\n", tmp(i), b(i));
    }
  }
#endif
} /* solveLinearSystem */

void prepareRow(
    /// [out] Eigen::Triplet<double> that we are updating
    std::vector<Eigen::Triplet<double> >& tripletList,
    /// [in] sparse matrix from COIN-OR, in row-major form
    const CoinPackedMatrix* const mat,
    /// [in] row we are inserting
    const int row,
    /// [in] row in which to insert this value
    const int tmp_row) {
  const int* cols = mat->getIndices();
  const double* elem = mat->getElements();

  const int start = mat->getVectorFirst(row);
  const int end = mat->getVectorLast(row);
  for (int ind = start; ind < end; ind++) {
    const double j = cols[ind];
    const double el = elem[ind];
    tripletList.push_back(Eigen::Triplet<double>(tmp_row,j,el));
  }
} /* prepareRow */

void insertRow(
    /// [out] sparse matrix, in row-major form
    Eigen::SparseMatrix<double,Eigen::RowMajor>& M,
    /// [in] sparse matrix from COIN-OR, in row-major form
    const CoinPackedMatrix* const mat,
    /// [in] row we are inserting
    const int row,
    /// [in] row in which to insert this entry
    const int tmp_row) {
  const int* cols = mat->getIndices();
  const double* elem = mat->getElements();

  const int start = mat->getVectorFirst(row);
  const int end = mat->getVectorLast(row);
  for (int ind = start; ind < end; ind++) {
    const double j = cols[ind];
    const double el = elem[ind];
    M.insert(tmp_row,j) = el;
  }
} /* insertRow */

/** Find alpha and beta such that alpha^T x >= beta for all x feasible for solver
 *  where alpha and beta are derived by taking a linear combination of solver's
 *  constraints with coefficients prescribed by the Farkas multipliers v.
 *  Note: First m+m_t rows of v correspond to A;D^t; the next n are bounds on the variables */
void getCutFromCertificate(
    /// [out] calculated cut coefficients
    std::vector<double>& alpha,
    /// [out] calculated cut bound
    double& beta,
    /// [in] Farkas multipliers
    const std::vector<double>& v,
    /// [in] LP solver corresponding to disjunctive term
    const OsiSolverInterface* const solver) {

  verify(!solver->isProvenPrimalInfeasible(),
         "cannot calculate cut with infeasible termSolver.\n");
  verify(v.size() == solver->getNumRows() + solver->getNumCols(), "The number of "
         "Farkas multipliers should match the number of constraints and variables.\n");

  alpha.clear();
  alpha.resize(solver->getNumCols(), 0.0);
  beta = 0.0;

  const CoinPackedMatrix* mat = solver->getMatrixByCol();
  double val;
  for (int col = 0; col < solver->getNumCols(); col++) {
    const int start = mat->getVectorFirst(col);
    const int colFarkasIndex = solver->getNumRows() + col;
    alpha[col] += dotProduct(mat->getVectorSize(col),
                             mat->getIndices() + start, mat->getElements() + start, v.data());
    alpha[col] += v[colFarkasIndex];
    if (greaterThanVal(v[colFarkasIndex], 0)){
      val = v[colFarkasIndex] * solver->getColLower()[col];
    } else if (lessThanVal(v[colFarkasIndex], 0)) {
      val = v[colFarkasIndex] * solver->getColUpper()[col];
    } else {
      val = 0.0;
    }
    verify((val < 1e30 && val > -1e30), "messed up a farkas cofficient");
    beta += val;
  }
  for (int row = 0; row < solver->getNumRows(); row++) {
    if (greaterThanVal(v[row], 0)){
      val = v[row] * solver->getRowLower()[row];
    } else if (lessThanVal(v[row], 0)) {
      val = v[row] * solver->getRowUpper()[row];
    } else {
      val = 0.0;
    }
    verify((val < 1e30 && val > -1e30), "messed up a farkas cofficient");
    beta += val;
  }
} /* getCutFromCertificate */

/** find the smallest value in each column given a vector of row vectors */
std::vector<double> elementWiseMax(std::vector< std::vector<double> > a){
  std::vector<double> maxes(a[0].size(), -1e50);
  for (int termIdx = 0; termIdx < a.size(); termIdx++){
    for (int colIdx = 0; colIdx < a[termIdx].size(); colIdx++){
      if (a[termIdx][colIdx] > maxes[colIdx]){
        maxes[colIdx] = a[termIdx][colIdx];
      }
    }
  }
  return maxes;
}

/** find the smallest value in a vector */
double min(std::vector<double> a){
  double min = 1e50;
  for (int i = 0; i < a.size(); i++){
    if (a[i] < min){
      min = a[i];
    }
  }
  return min;
}

/** check if sol is feasible for solver */
bool isFeasible(
    /// [in] problem
    const OsiSolverInterface& solver,
    /// [in] solution
    const std::vector<double>& sol) {

  // get bounds and constraint coefficients
  const double* rowLower = solver.getRowLower();
  const double* rowUpper = solver.getRowUpper();
  const double* colLower = solver.getColLower();
  const double* colUpper = solver.getColUpper();
  const CoinPackedMatrix* mat = solver.getMatrixByRow();
  const int* cols = mat->getIndices();
  const double* elem = mat->getElements();

  // check dimensions match
  verify(sol.size() == solver.getNumCols(), "solution has wrong dimension");

  // make sure constraints are valid
  for (int row = 0; row < solver.getNumRows(); row++) {
    double sum = 0.0;
    const int start = mat->getVectorFirst(row);
    const int end = mat->getVectorLast(row);
    for (int ind = start; ind < end; ind++) {
      const double j = cols[ind];
      const double el = elem[ind];
      sum += el * sol[j];
    }
    if (lessThanVal(sum, rowLower[row]) || greaterThanVal(sum, rowUpper[row])) {
      return false;
    }
  }

  // make sure variables are valid
  for (int col = 0; col < solver.getNumCols(); col++) {
    if (lessThanVal(sol[col], colLower[col]) || greaterThanVal(sol[col], colUpper[col])) {
      return false;
    }
    if (solver.isInteger(col) && !isInteger(sol[col])) {
      return false;
    }
  }
  return true;
} /* isFeasible */

/** check if cut is valid for given solution */
bool isFeasible(
    /// [in] problem
    const OsiRowCut& cut,
    /// [in] solution
    const std::vector<double>& sol) {

  double sum = 0.0;
  for (int ind = 0; ind < cut.row().getNumElements(); ind++) {
    const double j = cut.row().getIndices()[ind];
    const double el = cut.row().getElements()[ind];
    sum += el * sol[j];
  }
  if (lessThanVal(sum, cut.lb()) || greaterThanVal(sum, cut.ub())) {
    // print the sum, the cut lower bound, and cut upper bound
    std::cout << " lb: " << cut.lb() << "sum: " << sum << " ub: " << cut.ub() << std::endl;
    return false;
  } else {
    return true;
  }
} /* isFeasible */

/** check if a value is an integer */
bool isInteger(double val){
  return isZero(min(val - std::floor(val), std::ceil(val) - val));
}

/** take a min of two values */
double min(double a, double b){
  if (a < b){
    return a;
  } else {
    return b;
  }
}

/** find the nonzero indices and elemnets of a vector */
void findNonZero(
    /// [in] vector
    const std::vector<double>& vec,
    /// [out] indices of nonzero elements
    std::vector<int>& indices,
    /// [out] nonzero elements
    std::vector<double>& elements) {

  indices.clear();
  elements.clear();
  for (int i = 0; i < vec.size(); i++){
    if (!isZero(vec[i])){
      indices.push_back(i);
      elements.push_back(vec[i]);
    }
  }
}
